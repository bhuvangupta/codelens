package com.codelens.core;

import com.codelens.model.entity.ReviewComment;
import com.codelens.model.entity.ReviewIssue;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class CommentFormatter {

    private static final String HEADER = "## CodeLens AI Review\n\n";

    /**
     * Format a review comment for posting to GitHub PR
     * Shows all issues found grouped by severity
     */
    public String formatSummary(String summary, List<ReviewIssue> issues, ReviewStats stats, String reviewUrl) {
        StringBuilder sb = new StringBuilder();
        sb.append(HEADER);

        // Quick stats line
        sb.append(String.format("**%d files** reviewed | **%d issues** found\n\n",
            stats.filesReviewed(), issues.size()));

        // Issues section - show all issues grouped by severity
        if (!issues.isEmpty()) {
            List<ReviewIssue> critical = filterBySeverity(issues, ReviewIssue.Severity.CRITICAL);
            List<ReviewIssue> high = filterBySeverity(issues, ReviewIssue.Severity.HIGH);
            List<ReviewIssue> medium = filterBySeverity(issues, ReviewIssue.Severity.MEDIUM);
            List<ReviewIssue> low = filterBySeverity(issues, ReviewIssue.Severity.LOW);

            if (!critical.isEmpty()) {
                sb.append("### :rotating_light: Critical\n\n");
                formatIssueTable(sb, critical);
            }

            if (!high.isEmpty()) {
                sb.append("### :warning: High\n\n");
                formatIssueTable(sb, high);
            }

            if (!medium.isEmpty()) {
                sb.append("### :yellow_circle: Medium\n\n");
                formatIssueTable(sb, medium);
            }

            if (!low.isEmpty()) {
                sb.append("### :information_source: Low\n\n");
                formatIssueTable(sb, low);
            }
        } else {
            sb.append(":white_check_mark: **No issues found!**\n\n");
        }

        // Footer with review URL
        sb.append("\n---\n");
        if (reviewUrl != null && !reviewUrl.isEmpty()) {
            sb.append(":mag: **[View Full Review](").append(reviewUrl).append(")**\n\n");
        }
        sb.append("*Generated by CodeLens AI*");

        return sb.toString();
    }

    /**
     * Format issues as a markdown table
     */
    private void formatIssueTable(StringBuilder sb, List<ReviewIssue> issues) {
        sb.append("| Severity | File | Line | Issue | Source |\n");
        sb.append("|----------|------|------|-------|--------|\n");
        for (ReviewIssue issue : issues) {
            String severity = formatSeverityBadge(issue.getSeverity());
            String file = issue.getFilePath() != null ? truncateFilePath(issue.getFilePath()) : "-";
            String line = issue.getLineNumber() != null ? String.valueOf(issue.getLineNumber()) : "-";
            String description = truncateDescription(issue.getDescription());
            String source = formatSource(issue);
            sb.append(String.format("| %s | `%s` | %s | %s | %s |\n", severity, file, line, description, source));
        }
        sb.append("\n");
    }

    /**
     * Format issue source (AI or analyzer name)
     */
    private String formatSource(ReviewIssue issue) {
        if (issue.getSource() == ReviewIssue.Source.AI) {
            return "AI";
        } else if (issue.getAnalyzer() != null) {
            // Capitalize analyzer name (pmd -> PMD, eslint -> ESLint)
            String analyzer = issue.getAnalyzer().toLowerCase();
            return switch (analyzer) {
                case "pmd" -> "PMD";
                case "checkstyle" -> "Checkstyle";
                case "spotbugs" -> "SpotBugs";
                case "eslint" -> "ESLint";
                case "npm-audit" -> "NPM Audit";
                default -> analyzer.toUpperCase();
            };
        }
        return "Static";
    }

    /**
     * Format severity as text for table
     */
    private String formatSeverityBadge(ReviewIssue.Severity severity) {
        if (severity == null) return "-";
        return severity.toString();
    }

    /**
     * Truncate file path to show only filename or last part
     */
    private String truncateFilePath(String path) {
        if (path == null) return "-";
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash >= 0 && lastSlash < path.length() - 1) {
            return path.substring(lastSlash + 1);
        }
        return path;
    }

    /**
     * Truncate long descriptions for table display
     */
    private String truncateDescription(String desc) {
        if (desc == null) return "-";
        // Remove markdown formatting that might break table
        desc = desc.replace("|", "\\|").replace("\n", " ");
//        if (desc.length() > 80) {
//            return desc.substring(0, 77) + "...";
//        }
        return desc;
    }

    /**
     * Format an inline comment
     */
    public String formatInlineComment(ReviewComment comment) {
        StringBuilder sb = new StringBuilder();

        // Severity badge
        sb.append(getSeverityBadge(comment.getSeverity())).append(" ");
        sb.append("**").append(comment.getCategory()).append("**\n\n");

        // Comment body
        sb.append(comment.getBody()).append("\n");

        // Suggestion if present
        if (comment.getSuggestion() != null && !comment.getSuggestion().isEmpty()) {
            sb.append("\n**Suggestion:**\n");
            sb.append("```suggestion\n");
            sb.append(comment.getSuggestion());
            sb.append("\n```\n");
        }

        return sb.toString();
    }

    /**
     * Format a CVE issue for display
     */
    public String formatCveIssue(ReviewIssue issue) {
        StringBuilder sb = new StringBuilder();
        sb.append(":shield: **Security Vulnerability**\n\n");

        if (issue.getCveId() != null) {
            sb.append("**CVE:** ").append(issue.getCveId()).append("\n");
        }
        if (issue.getCvssScore() != null) {
            sb.append("**CVSS Score:** ").append(issue.getCvssScore()).append("\n");
        }

        sb.append("\n").append(issue.getDescription()).append("\n");

        if (issue.getSuggestion() != null) {
            sb.append("\n**Remediation:**\n").append(issue.getSuggestion()).append("\n");
        }

        return sb.toString();
    }

    /**
     * Format issues for a specific file
     */
    public String formatFileIssues(String filePath, List<ReviewIssue> issues) {
        StringBuilder sb = new StringBuilder();
        sb.append("### Issues in `").append(filePath).append("`\n\n");

        for (ReviewIssue issue : issues) {
            sb.append("- ");
            sb.append(getSeverityBadge(issue.getSeverity())).append(" ");
            if (issue.getLineNumber() != null) {
                sb.append("Line ").append(issue.getLineNumber()).append(": ");
            }
            sb.append(issue.getDescription()).append("\n");
        }

        return sb.toString();
    }

    private void formatIssueList(StringBuilder sb, List<ReviewIssue> issues) {
        for (ReviewIssue issue : issues) {
            sb.append("- ");
            if (issue.getFilePath() != null) {
                sb.append("`").append(issue.getFilePath());
                if (issue.getLineNumber() != null) {
                    sb.append(":").append(issue.getLineNumber());
                }
                sb.append("` - ");
            }
            sb.append(issue.getDescription()).append("\n");
        }
        sb.append("\n");
    }

    private List<ReviewIssue> filterBySeverity(List<ReviewIssue> issues, ReviewIssue.Severity severity) {
        return issues.stream()
            .filter(i -> i.getSeverity() == severity)
            .toList();
    }

    private String getSeverityBadge(ReviewComment.Severity severity) {
        return switch (severity) {
            case CRITICAL -> ":rotating_light:";
            case HIGH -> ":warning:";
            case MEDIUM -> ":yellow_circle:";
            case LOW -> ":information_source:";
            case INFO -> ":bulb:";
        };
    }

    private String getSeverityBadge(ReviewIssue.Severity severity) {
        return switch (severity) {
            case CRITICAL -> ":rotating_light:";
            case HIGH -> ":warning:";
            case MEDIUM -> ":yellow_circle:";
            case LOW -> ":information_source:";
            case INFO -> ":bulb:";
        };
    }

    /**
     * Review statistics
     */
    public record ReviewStats(
        int filesReviewed,
        int linesAdded,
        int linesRemoved
    ) {}
}
